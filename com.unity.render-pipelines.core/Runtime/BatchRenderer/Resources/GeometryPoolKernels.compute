#pragma kernel MainUpdateIndexBuffer16
#pragma kernel MainUpdateIndexBuffer32

//#pragma enable_d3d11_debug_symbols

ByteAddressBuffer _InputIndexBuffer;
RWByteAddressBuffer _OutputIndexBuffer;

#define _InputIBOffset  0

int _InputIBCount;
int _OutputIBOffset;

#define GROUP_SIZE_X 64
#define GROUP_SIZE_X_HALF (GROUP_SIZE_X >> 1)

[numthreads(GROUP_SIZE_X,1,1)]
void MainUpdateIndexBuffer32(uint3 dispatchThreadID : SV_DispatchThreadID)
{
    uint bufferOffset = dispatchThreadID.x;
    if (bufferOffset >= (uint)_InputIBCount)
        return;

    uint storageAddress = ((uint)_OutputIBOffset + bufferOffset) << 2u;
    _OutputIndexBuffer.Store(storageAddress, _InputIndexBuffer.Load((_InputIBOffset + bufferOffset) << 2u));
}

groupshared uint _ldsIndexCache[GROUP_SIZE_X >> 1];

[numthreads(GROUP_SIZE_X,1,1)]
void MainUpdateIndexBuffer16(uint3 dispatchThreadID : SV_DispatchThreadID, uint groupIndex : SV_GroupIndex, uint3 groupID : SV_GroupID)
{
    //only load half the data.
    if (groupIndex < GROUP_SIZE_X_HALF)
        _ldsIndexCache[groupIndex] = _InputIndexBuffer.Load((GROUP_SIZE_X_HALF * groupID.x + groupIndex) << 2u);

    GroupMemoryBarrierWithGroupSync();

    uint bufferOffset = dispatchThreadID.x;
    if (bufferOffset >= (uint)_InputIBCount)
        return;

    uint pair = _ldsIndexCache[groupIndex >> 1u];
    uint value = (groupIndex.x & 0x1) ? (pair >> 16) : (pair & 0xffff);

    uint storageAddress = ((uint)_OutputIBOffset + bufferOffset) << 2;
    _OutputIndexBuffer.Store(storageAddress, value);
}
